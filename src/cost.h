#ifndef _COST_H_
#define _COST_H_

#include <iostream>
#include <vector>
#include <map>
#include "vehicle.h"
#include "utils.h"

using namespace std;

namespace
{
namespace cost
{

struct cost_context
{
    const Road* road; // a pointer to the road instance initialized in main.cpp;
    Target target; // the target given by the behavior module
    vector<Vehicle> trajectory; // rough trajectory generated by the behavior module
    map<int, vector<Vehicle>> predictions; // non-ego cars' predictions
};

/**
 * Applyes penaly for trajectories which have collisions.
 */ 
double collision_cost(const cost_context& ctx)
{
    double width = Vehicle::WIDTH * 1.1;
    double length = Vehicle::LENGTH * 1.1;

    // for each trajectory state check whether ego-car collides with non-ego cars
    int n_iter = ctx.trajectory.size();
    for(int i=0; i<n_iter; i++) {
        auto self = ctx.trajectory.at(i);

        double self_l = self.d - 0.5*width;
        double self_r = self.d + 0.5*width;
        double self_t = self.s + 0.5*length;
        double self_b = self.s - 0.5*length;

        for(auto it=ctx.predictions.begin(); it != ctx.predictions.end(); ++it) {
            auto v = it->second.at(i);

            double v_l = v.d - 0.5*width;
            double v_r = v.d + 0.5*width;
            double v_t = v.s + 0.5*length;
            double v_b = v.s - 0.5*length;

            // https://stackoverflow.com/questions/306316/determine-if-two-rectangles-overlap-each-other
            bool is_collision = self_l <= v_r && self_r >= v_l && self_t >= v_b && self_b <= v_t;
            if (is_collision) {
                // std::cout << "collision_cost: detected collision" << std::endl;
                return 1;
            }
        }
    }
    // no collisions
    return 0;
}

/**
 * Adds penalty for lane change maneuvers if there're vehicles in the left(right) of the ego-car
 */
double maneuver_safety_cost(const cost_context& ctx)
{
    double s_buff = 4.0; // meter
    auto self = ctx.trajectory.at(0);
    int self_lane = ctx.road->get_lane(self.d);
    int target_lane = ctx.target.lane;
    
    if (self_lane == target_lane) return 0;

    // define a zone in which we don't expect any vehicles when starting maneuver
    double l = self.d;
    double r = l + ctx.road->lane_width;
    double t = self.s + 0.5*Vehicle::LENGTH + s_buff;
    double b = self.s - 0.5*Vehicle::LENGTH - s_buff;

    // adjust the zone if it is the left maneuver
    if (target_lane < self_lane)
    {
        l -= Vehicle::WIDTH;
        r -= Vehicle::WIDTH;
    }

    for(auto it=ctx.predictions.begin(); it != ctx.predictions.end(); ++it)
    {
        auto v = it->second.at(0); // the initial position of the vehicle
        double v_l = v.d - 0.5*Vehicle::WIDTH;
        double v_r = v.d + 0.5*Vehicle::WIDTH;
        double v_t = v.s + 0.5*Vehicle::LENGTH;
        double v_b = v.s - 0.5*Vehicle::LENGTH;

        bool intersects = l <= v_r && r >= v_l && t >= v_b && b <= v_t;
        if (intersects) 
        {
            return 1;
        }
    }
    
    // all clear, maneuver is safe
    return 0;
}

/**
 * Cost becomes higher if the ego-car moves slower.
 */
double inefficiency_cost(const cost_context& ctx)
{
    double speed_limit = 50;

    double max_speed_sum = ctx.trajectory.size() * speed_limit;
    double speed_sum = 0.0;
    for(auto it=ctx.trajectory.begin(); it != ctx.trajectory.end(); ++it)
    {
        speed_sum += it->speed;
    }

    return (max_speed_sum - speed_sum) / max_speed_sum;
}

/**
 * Adds penalty for a lane change.
 */
double change_lane_cost(const cost_context& ctx)
{
    Vehicle self = ctx.trajectory.at(0);
    if (ctx.target.lane != ctx.road->get_lane(self.d)) return 1;
    return 0;
}

} // namespace cost    
} // namespace

#endif // _COST_H_